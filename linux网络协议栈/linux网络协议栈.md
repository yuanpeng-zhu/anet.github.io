# linux 网络协议栈

![[Pasted image 20240926142255.png]]

## 一、网络协议分层

网络协议分层通常采用分层模型来组织和简化网络通信的复杂性。最常见的分层模型是 OSI 模型和 TCP/IP 模型。
<!-- ![[../picture/Pasted image 20240925210807.png]] -->
![alt text](../picture/Pasted%20image%2020240925210807.png)
### OSI 模型（七层）
1. **物理层**：传输原始比特流，涉及硬件设备和电气信号。
2. **数据链路层**：提供节点间的数据传输，处理帧的错误检测和修正。
3. **网络层**：负责数据包的路由和转发，处理逻辑地址（如 IP 地址）。
4. **传输层**：提供端到端的通信，确保数据完整性和顺序，使用 TCP 或 UDP。
5. **会话层**：管理会话的建立、维护和终止，处理应用程序之间的交互。
6. **表示层**：处理数据格式转换、加密和压缩，确保应用能够理解数据。
7. **应用层**：提供网络服务给用户和应用程序，涉及 HTTP、FTP、SMTP 等协议。
### TCP/IP 模型（四层）
1. **网络接口层**：对应 OSI 的物理层和数据链路层，处理硬件和帧传输。
2. **互联网层**：对应 OSI 的网络层，负责数据包的路由和寻址，主要使用 IP 协议。
3. **传输层**：对应 OSI 的传输层，使用 TCP 和 UDP 来提供端到端的通信。
4. **应用层**：对应 OSI 的会话层、表示层和应用层，提供用户和应用程序的网络服务。

## 二、数据报文封装过程

![[../picture/Pasted image 20240925210915.png]]
数据报文在协议栈中的封装过程涉及将应用层数据逐层添加协议头（和可能的尾），以便在网络上传输。接收方则会按相反的顺序解封装数据，从物理层到应用层，提取出原始数据供应用程序使用。


## 三、linux网络协议栈
linux网络发送处理过程如下图所示：
<!-- ![[../picture/Pasted image 20240925212532.png]] -->
![alt text](../picture/Pasted%20image%2020240925212532.png)
数据被系统调用拷贝到内核态，然后经过协议栈处理后进⼊RingBuffer。随后⽹卡驱动真正将数据发送了出去。
网络协议栈处理包括传输层处理（tcp/udp等），接着进行网络层处理（ipv4/ipv6）。
linux网络链路层实现由各个驱动设备实现，最终通过网卡完成发送过程。
此处以tcp协议、ipv4协议为例，简要概述linux内核网络协议栈处理报文的过程。

<!-- ![[../picture/Pasted image 20240926093404.png]] -->
![alt text](../picture/Pasted%20image%2020240926093404.png)
跨机网络通信流程总体如下：
### 发送过程
#### 1 传输层实现
`socket`系统调用通过调用`sock->ops->semndmsg()`，调用传输层的`inet_sendmsg()`。
同样，`inet_sendmsg`通过`sk_prot`选择`tcp_sendmsg()`发送数据。
在传输层将应用层下发的数据进行封装，对于tcp，会添加序列号、校验号等信息。对于tcp，还会在其中通过滑动窗口实现拥塞控制。
最终，在`tcp_transmit_skb()`调用网络层发送接口，将数据包发送至网络层进行处理。
#### 2 网络层实现
传输层调用`ip_queue_xmit()`,将数据包交付网络层进行处理。
具体处理包括：ip等信息封装、将传输层报文进行封装以及重组。
网络层经过处理后将通过`dst_neigh_output`交付邻居子系统进行处理。
#### 3 邻居子系统
网络邻居子系统（Neighbor Subsystem）主要负责管理本地网络中的邻居节点的信息。其功能包括：邻居发现、邻居状态监控、地址解析等。通过这些功能，邻居子系统帮助 Linux 内核有效地管理网络邻居关系，确保数据包能够正确和高效地路由到目标节点。
邻居子系统通过`dev_queue_xmit()`将数据交付网络设备子系统进行处理。
#### 4. 网络设备子系统
核心处理函数`dev_queue_xmit()`以及`dev_hard_start_xmit()`。
将数据包发送给网卡设备。

#### 5. 网络设备
网络设备驱动程序将数据包从网卡发送出去。
网络发送完毕后，网卡会给CPU发送一个硬中断。
CPU处理硬中断，释放缓存。

## 接收过程

#### 1. 网卡接收
网卡接收到数据后，向CPU发送中断，通知CPU有数据到达。
CPU收到中断请求后，调用网络驱动注册的中断处理函数，轮询收包。
具体表现为`igb_msix_ring()调用__napi_schedule`,其中触发软中断`__raise_softirq_irqoff()

#### 2. 进入软中断处理
核心函数为`net_rx_action`， `igb_poll`等。
在`deliver_skb`中，调用`pt_prev->func()`进入网络协议栈进行处理。

#### 3. 进入网络层处理
`pt_prev->func()`调用`ip_rccv`进行处理。
处理包含验证IP头部的合法性、根据IP头部中的协议类型字段，确定数据包应该传递给哪个传输层协议、如果接收到的数据包是之前被分片的数据包的一部分，IP层会负责将这些分片重新组合成原始的数据包。
处理完成将报文交付对应的传输层处理函数进行处理。

#### 4. 进入传输层处理
传输层由`tcp_v4_rcv()`开始进行处理。
传输层将报文进行解封装成应用层需要的报文，对于tcp需要进行排序，重组、校验。
`tcp_queue_rcv`将数据读取到接收队列中，
之后唤醒socket阻塞掉的进程。

#### 5. 进入用户进程处理
用户态的`recv`调用的系统调用将数据放在buff中返回。




## 参考
[深入理解Linux网络： 修炼底层内功，掌握高性能原理 (豆瓣) (douban.com)](https://book.douban.com/subject/35922722/)
[计算机网络：TCP/IP 协议栈概述 - 乌漆WhiteMoon - 博客园 (cnblogs.com)](https://www.cnblogs.com/linfangnan/p/13252843.html)
[理解 Linux 网络栈（1）：Linux 网络协议栈简单总结 - SammyLiu - 博客园 (cnblogs.com)](https://www.cnblogs.com/sammyliu/p/5225623.html#:~:text=%E6%9C%AC%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E6%80%BB)


