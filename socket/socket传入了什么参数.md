Socket（套接字）是计算机网络中的一种通信方式，简单来说，它是两台计算机（或者两个设备）之间交流的"接口"或"通道"。就像打电话时，你需要一个电话来拨号和通话，Socket 就是网络中的“电话”，它负责创建一条通路，让两台设备能够通过网络发送和接收数据。

## 参数1：协议族
在 Linux 系统中，`socket` 系统调用支持多种协议族（Protocol Family），每种协议族通常对应一个特定的通信方式或网络层次。这些协议族被指定为 `socket` 系统调用的第一个参数，用来告诉操作系统这个套接字将用于哪种通信协议。
以下是常见的协议族及其用途：
#### 1. **PF_INET（AF_INET）**
   - **用途**: 这是最常用的协议族，代表 IPv4 网络协议族，用于基于 IPv4 的网络通信。
   - **示例**: 用于创建 TCP 和 UDP 套接字进行网络通信。
   - **调用方式**: 
     ```c
     socket(PF_INET, SOCK_STREAM, 0); // 创建一个 IPv4 TCP socket
     ```
#### 2. **PF_INET6（AF_INET6）**
   - **用途**: 代表 IPv6 网络协议族，用于基于 IPv6 的网络通信。
   - **示例**: 用于创建 IPv6 上的 TCP 和 UDP 套接字。
   - **调用方式**:
     ```c
     socket(PF_INET6, SOCK_STREAM, 0); // 创建一个 IPv6 TCP socket
     ```
#### 3. **PF_UNIX（AF_UNIX 或 AF_LOCAL）**
   - **用途**: 代表 Unix 域套接字协议族，主要用于本地进程间通信（IPC），而不是通过网络通信。
   - **示例**: 允许同一台机器上的进程之间使用文件系统路径标识的套接字进行通信。
   - **调用方式**:
     ```c
     socket(PF_UNIX, SOCK_STREAM, 0); // 创建一个本地 Unix 套接字
     ```
#### 4. **PF_NETLINK**
   - **用途**: 用于用户空间与 Linux 内核之间的双向通信，常用于网络子系统的管理，如路由表、网络接口状态等。
   - **示例**: `NETLINK_ROUTE` 允许管理网络路由、接口、邻居信息等。
   - **调用方式**:
     ```c
     socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE); // 创建一个 Netlink 路由套接字
     ```
#### 5. **PF_PACKET**
   - **用途**: 提供底层数据包接口，允许直接操作链路层（如以太网帧）。它能够收发未处理的网络数据包。
   - **示例**: 常用于网络分析工具（如 tcpdump）和自定义协议实现。
   - **调用方式**:
     ```c
     socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL)); // 捕获所有链路层数据包
     ```
#### 6. **PF_BRIDGE**
   - **用途**: 用于与网络桥接设备通信，主要用于与网络桥接（Linux Bridge）相关的功能。
   - **示例**: 在管理网络桥接时用作控制套接字。
   - **调用方式**:
     ```c
     socket(PF_BRIDGE, SOCK_RAW, ETH_P_ALL);
     ```
### 7. 其他协议若干………………


## 参数2：套接字类型
Socket（套接字）是网络编程的核心部分。套接字有多种类型，取决于它们用于通信的方式和通信的协议。以下是几种主要的 Socket 套接字类型及其用途：
#### 1. **流式套接字（SOCK_STREAM）**
- **简介**: 流式套接字用于基于 TCP（传输控制协议）的通信，提供面向连接的、可靠的双向字节流传输。
- **特点**:
  - 面向连接：通信双方需要先建立连接（通过三次握手）。
  - 数据传输有序且可靠：确保数据按照发送顺序到达，并且如果数据丢失，会进行重传。
  - 持续数据流：可以不断发送和接收数据，直到一方关闭连接。
  - 典型场景：常用于需要稳定、可靠连接的场景，如网页浏览（HTTP/HTTPS）、文件传输（FTP）、邮件传输（SMTP/IMAP）等。
- **应用举例**: 浏览器和服务器之间的通信就是通过 `SOCK_STREAM` 套接字完成的，它确保了网页数据能正确地传输并显示在浏览器中。
- **调用示例**:
  ```c
  int sock = socket(AF_INET, SOCK_STREAM, 0); // 创建一个 TCP 套接字
  ```
#### 2. **数据报套接字（SOCK_DGRAM）**
- **简介**: 数据报套接字基于 UDP（用户数据报协议），用于无连接的、不可靠的数据传输。
- **特点**:
  - 无连接：不需要建立和维持连接，数据可以直接发送给接收方。
  - 不可靠：数据可能丢失、重复、乱序，不保证数据按顺序到达，也不保证对方收到数据。
  - 适合小数据包：通常用于发送短消息，不适合传输大量数据。
  - 低开销：由于不需要维护连接和数据重传，数据报套接字的性能通常高于流式套接字。
  - 典型场景：常用于实时通信或广播场景，如视频流、音频流、在线游戏、DNS 查询等。
- **应用举例**: 在线视频直播通常使用 `SOCK_DGRAM`，因为即使丢失一些数据包，也不会对整体流媒体造成太大影响。

- **调用示例**:
  ```c
  int sock = socket(AF_INET, SOCK_DGRAM, 0); // 创建一个 UDP 套接字
  ```
#### 3. **原始套接字（SOCK_RAW）**
- **简介**: 原始套接字用于直接访问网络协议栈的底层，允许应用程序直接读取和写入 IP 层及以下的网络帧数据。
- **特点**:
  - 直接访问底层数据包：应用程序可以自己构造协议头部，直接操作链路层（如以太网）或网络层（如 IP 层）数据。
  - 常用于网络监控、网络分析工具：比如捕获所有进出网卡的数据包，不限于特定的协议。
  - 需要较高的权限：创建原始套接字通常需要超级用户权限（`root`），因为它允许操作和监控网络底层。
  - 典型场景：网络工具如 `tcpdump`、`Wireshark` 使用原始套接字来捕获和分析网络流量。
- **应用举例**: 网络抓包工具 `tcpdump` 就使用 `SOCK_RAW` 来捕获网络上的所有数据包，不管是 TCP、UDP 还是 ICMP。
- **调用示例**:
  ```c
  int sock = socket(AF_INET, SOCK_RAW, IPPROTO_TCP); // 创建一个原始套接字，捕获 TCP 数据包
  ```
#### 4. **顺序分组套接字（SOCK_SEQPACKET）**
- **简介**: 顺序分组套接字提供一种有序的数据传输模式，它类似于流式套接字（TCP），但其传输的是固定大小的消息或数据包，并且每个消息都是完整的。
- **特点**:
  - 面向连接：和 `SOCK_STREAM` 类似，通信双方必须建立连接。
  - 数据包有序：数据以分组的形式传输，接收方按照发送方的顺序接收。
  - 保证消息边界：每个发送的数据包是独立的，不会和其他数据包混合。
  - 适合定长消息的传输：用于对数据边界有严格要求的场景。
  - 典型场景：此类套接字常用于某些实时系统或电信系统中，用于在严格的消息边界要求下传输数据。
- **应用举例**: `SOCK_SEQPACKET` 常用于本地通信的 `AF_UNIX` 域套接字。
- **调用示例**:
  ```c
  int sock = socket(AF_UNIX, SOCK_SEQPACKET, 0); // 创建一个本地的顺序分组套接字
  ```
#### 5. **可靠数据报套接字（SOCK_RDM）**
- **简介**: 可靠数据报套接字的概念与 UDP 相似，但保证了消息的可靠性和无重复性。尽管它设计上有一定的优势，但在实际使用中，这种套接字类型较为罕见，通常并未在大多数操作系统中广泛实现。
- **特点**:
  - 无连接：像 `SOCK_DGRAM` 一样，不需要建立连接。
  - 消息的可靠传输：保证消息不会丢失或重复，但并不保证消息的顺序。
  - 典型场景：这个类型的套接字并不常用，在 Linux 中几乎没有使用。
- **调用示例**:
  ```c
  int sock = socket(AF_INET, SOCK_RDM, 0); // 创建一个可靠数据报套接字
  ```
#### 6. **无连接套接字（SOCK_NONBLOCK 或 SOCK_CLOEXEC）**
- **简介**: 无连接套接字（通常与其他套接字类型一起使用）允许创建一个非阻塞的套接字或一个自动关闭的套接字。
  - **SOCK_NONBLOCK**: 非阻塞模式，在没有数据时不会阻塞调用，而是立即返回。
  - **SOCK_CLOEXEC**: 在进程调用 `exec` 时，自动关闭套接字，避免资源泄露。
- **特点**:
  - 非阻塞 I/O：对于长时间的 I/O 操作（如网络通信），这种套接字类型可以避免阻塞主线程。
  - 典型场景：用于提高并发性，特别是在事件驱动的服务器模型中非常有用。
- **应用举例**: 高性能网络服务器如 `Nginx` 或 `Node.js` 常用非阻塞套接字处理并发连接。
- **调用示例**:
  ```c
  int sock = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0); // 创建一个非阻塞 TCP 套接字
  ```
